{
  "description": "Generated by Gemini.",
  "prompt": "Build a \"Project Assistant App,\" an interactive, single-page web application for project management and consultancy. The application should be built with React and TypeScript, using Vite as the build tool.\n\nThe core of the app is a chat-based interface where a user interacts with an AI project consultant. The user begins by defining a project, which creates a project object stored in the browser's local storage to persist the session.\n\nThe main screen is a \"Consultancy Screen\" with a project details pane on the left and a chat interface on the right. As the user provides updates on their project's progress, the AI assistant will dynamically update a task list, mark steps as complete, suggest next actions, and provide hints when the user is stuck. The entire interaction history should be saved and displayed in a log format.\n\nTechnical Specifications:\n1. Core Data Structure (project object):\n\nThis object is the central data structure for the application, stored in the browser's local storage to persist the project state. It should be defined with the following TypeScript interfaces:\n\nTypeScript\n\ninterface Project {\n  projectName: string;\n  projectType: string; // e.g., \"Web App,\" \"Mobile App,\" \"Data Science\"\n  projectGoals: string[];\n  tasks: Task[];\n  progress: number; // Percentage, 0-100\n  priorities: { \n    speed: number; // -100 (Focus on Quality) to 100 (Focus on Speed)\n    scope: number; // -100 (Stick to MVP) to 100 (Feature Rich)\n  };\n  stakeholders: Stakeholder[];\n  timeline: {\n    startDate: string;\n    targetDate: string;\n  };\n  blockers: Blocker[];\n  resources: Resource[];\n}\n\ninterface Task {\n  id: string;\n  name: string;\n  description: string;\n  status: 'Not Started' | 'In Progress' | 'Completed' | 'Blocked';\n  subtasks: Task[];\n}\n\ninterface Stakeholder {\n  name: string;\n  role: string;\n  contact: string;\n}\n\ninterface Blocker {\n  id: string;\n  description: string;\n  resolved: boolean;\n}\n\ninterface Resource {\n    name: string;\n    type: 'Tool' | 'Library' | 'Documentation' | 'Human Resource';\n    url?: string;\n    description: string;\n}\n2. Core UI Components:\n\nThe application should be composed of the following React components:\n\nProjectCreationScreen: The initial screen for new users. This component should feature a form to collect the projectName, projectType, and initial projectGoals. Upon submission, it should generate the initial project object and transition the user to the ConsultancyScreen.\n\nConsultancyScreen: The main view of the application, which should be split into two panes.\n\nProjectPane (Left): This pane displays the current state of the project object. It should include:\n\nThe project's name and type.\n\nA progress bar to visualize the overall project progress.\n\nA dynamic, nested list of tasks with interactive elements (e.g., checkboxes) to mark them as complete.\n\nClearly organized lists of blockers, stakeholders, and resources.\n\nChatPane (Right): This is the primary interaction area and should contain:\n\nConsultancyLog: A component that displays the conversation history between the user and the AI consultant.\n\nActionPanel: An input field for the user to type their messages, along with buttons for suggested actions provided by the AI.\n\n3. Schemas for AI Interaction:\n\nThe interaction with the Gemini model should be governed by the following strict JSON schemas.\n\nprojectCreationSchema: This schema is used when the user first creates a new project.\n\nJavaScript\n\nconst projectCreationSchema = {\n  type: Type.OBJECT,\n  properties: {\n    project: {\n      type: Type.OBJECT,\n      properties: {\n        projectName: { type: Type.STRING },\n        projectType: { type: Type.STRING },\n        projectGoals: { type: Type.ARRAY, items: { type: Type.STRING } },\n        initialTasks: {\n          type: Type.ARRAY,\n          description: \"An initial list of 3-5 high-level tasks to start the project.\",\n          items: {\n            type: Type.OBJECT,\n            properties: {\n              name: { type: Type.STRING },\n              description: { type: Type.STRING }\n            },\n            required: ['name', 'description']\n          }\n        }\n      },\n      required: ['projectName', 'projectType', 'projectGoals', 'initialTasks']\n    },\n    openingStatement: { \n        type: Type.STRING, \n        description: \"A welcoming message for the user that confirms the project has been created and suggests a first step.\"\n    },\n    suggestedActions: { \n        type: Type.ARRAY, \n        items: { type: Type.STRING }, \n        description: \"An array of 2-3 initial actions or questions that the user can take.\"\n    }\n  },\n  required: ['project', 'openingStatement', 'suggestedActions']\n};\nnextStepSchema: This is the primary schema for handling the ongoing chat interaction between the user and the AI consultant.\n\nJavaScript\n\nconst nextStepSchema = {\n    type: Type.OBJECT,\n    properties: {\n        consultancyUpdate: {\n            type: Type.OBJECT,\n            properties: {\n                responseText: { type: Type.STRING, description: \"The AI consultant's response to the user's message.\"},\n                suggestedActions: { type: Type.ARRAY, items: { type: Type.STRING }, description: \"A new array of 2-3 suggested actions or questions for the user.\"},\n                progressUpdate: { type: Type.INTEGER, description: \"The number of percentage points the overall project progress has changed. This can be a positive or negative integer.\"},\n                priorityUpdate: {\n                    type: Type.OBJECT,\n                    description: \"How the user's message affects the project's priorities. This should be omitted if there is no change.\",\n                    nullable: true,\n                    properties: {\n                        speed: { type: Type.INTEGER, description: \"The change in the speed vs. quality priority.\" },\n                        scope: { type: Type.INTEGER, description: \"The change in the MVP vs. feature-rich priority.\" }\n                    }\n                },\n                blockerIdentified: { type: Type.BOOLEAN, description: \"Set to true if the user's message has identified a new blocker.\"},\n                blockers: {\n                    type: Type.ARRAY,\n                    description: \"If blockerIdentified is true, provide an array of the new blockers. Otherwise, this should be null.\",\n                    items: {\n                        type: Type.OBJECT,\n                        properties: {\n                            description: { type: Type.STRING }\n                        },\n                        required: ['description']\n                    }\n                },\n                taskUpdates: {\n                    type: Type.ARRAY,\n                    description: \"An array of updates to the project's tasks. This should be used to add, complete, delete, or modify tasks.\",\n                    nullable: true,\n                    items: {\n                        type: Type.OBJECT,\n                        properties: {\n                            taskId: { type: Type.STRING, description: \"The ID of the task to update. For new tasks, this can be omitted and a placeholder name can be used.\"},\n                            name: { type: Type.STRING },\n                            description: { type: Type.STRING },\n                            status: { type: Type.STRING, description: \"The new status of the task: 'Not Started', 'In Progress', 'Completed', or 'Blocked'.\"},\n                            action: { type: Type.STRING, description: \"The action to perform on the task: 'add', 'remove', 'update', or 'complete'.\" }\n                        },\n                        required: ['name', 'action']\n                    }\n                },\n                milestoneCheck: {\n                    type: Type.OBJECT,\n                    description: \"Details of a milestone check. This should be included if the user's update implies that a major milestone has been reached.\",\n                    nullable: true,\n                    properties: {\n                        milestoneName: { type: Type.STRING },\n                        achieved: { type: Type.BOOLEAN },\n                        commentary: { type: Type.STRING, description: \"A comment on the achievement of the milestone.\" },\n                    },\n                    required: ['milestoneName', 'achieved', 'commentary']\n                }\n            },\n            required: ['responseText', 'suggestedActions', 'progressUpdate']\n        }\n    },\n    required: ['consultancyUpdate']\n}\n4. Application Flow:\n\nOn Initial Load: The application should check the browser's local storage for a saved project object.\n\nIf a project object is found, the application should load the ConsultancyScreen and populate it with the saved project state.\n\nIf no project object is found, the application should display the ProjectCreationScreen.\n\nProject Creation: The user fills out the project creation form. Upon submission, the application sends the details to the Gemini model with the projectCreationSchema. The AI's response is then used to populate the initial project object and display the first message in the ConsultancyLog.\n\nConsultancy Interaction: The user interacts with the AI through the ChatPane.\n\nEach message from the user is sent to the Gemini model, along with the current project state and the recent conversation history. The nextStepSchema is used to structure the AI's response.\n\nThe application then parses the JSON response from the AI.\n\nIt updates the project object in the application's state (and subsequently in local storage) based on the data in fields such as taskUpdates, progressUpdate, and blockers.\n\nThe responseText is appended to the ConsultancyLog.\n\nThe suggestedActions are displayed as new, clickable buttons in the ActionPanel.\n\nState Management: The application should use React's useState and useEffect hooks for all state management. Any changes to the project's state must be saved to local storage to ensure data persistence across sessions.",
  "requestFramePermissions": [],
  "name": "App"
}